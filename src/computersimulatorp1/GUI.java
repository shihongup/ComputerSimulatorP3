/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package computersimulatorp1;

import java.awt.event.ActionListener;
import static java.lang.Thread.sleep;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author group 10
 */
public class GUI extends javax.swing.JFrame {

    int flag = 0;   //The flag that controls SingleStep

    int GPR0 = 0;   //General Purpose Register (GPR)
    int GPR1 = 0;
    int GPR2 = 0;
    int GPR3 = 0;

    int StringToInt;

    String IX1 = "";//Index Register (IX)
    String IX2 = "";
    String IX3 = "";

    //String MAR = "";
    //String MBR = "";
    String[] memory = new String[4096];
    String PCaddress = ""; //Program Counter (PC) value

    String PCPlus1Address = "";
    String MARaddress = ""; //Memory Access Register (MAR) value
    String MBRvalue = "";   //Memory Buffer Register (MBR) value
    String IRvalue = "";    //Instruction Register (IR) value
    String IARvalue = "";   //Internal Address Register (IAR, store Effective Address after addressing)
    String CCRvalue = "";
    String opCode = ""; //Splitting parts of an instruction
    String GRNum = "";
    String IXNum = "";
    String I = "";
    String Address = "";
    String DevID = "";//represent which peripheral would be used

    //variable for function SRC & RRC
    String A_L = ""; //to determine logical or arithmetic shift or rotate
    String L_R = ""; //to determine left shift or right shift
    String count = ""; //to determine how many bits to move

    //variable for TRAP Function
    String TrapCode;

    //
    boolean StopFlag = false;

    /**
     * Creates new form GUI
     */
    public GUI() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        R0 = new javax.swing.JTextField();
        R1 = new javax.swing.JTextField();
        R2 = new javax.swing.JTextField();
        R3 = new javax.swing.JTextField();
        jLabel7 = new javax.swing.JLabel();
        PC = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jLabel11 = new javax.swing.JLabel();
        X1 = new javax.swing.JTextField();
        X2 = new javax.swing.JTextField();
        X3 = new javax.swing.JTextField();
        jLabel12 = new javax.swing.JLabel();
        MAR = new javax.swing.JTextField();
        jLabel13 = new javax.swing.JLabel();
        MBR = new javax.swing.JTextField();
        jLabel14 = new javax.swing.JLabel();
        IR = new javax.swing.JTextField();
        jLabel15 = new javax.swing.JLabel();
        CC = new javax.swing.JTextField();
        jLabel16 = new javax.swing.JLabel();
        MFR = new javax.swing.JTextField();
        jLabel17 = new javax.swing.JLabel();
        SetPC = new javax.swing.JButton();
        SetMAR = new javax.swing.JButton();
        SetMBR = new javax.swing.JButton();
        SetR0 = new javax.swing.JButton();
        SetR1 = new javax.swing.JButton();
        SetR2 = new javax.swing.JButton();
        SetR3 = new javax.swing.JButton();
        SetX1 = new javax.swing.JButton();
        SetX2 = new javax.swing.JButton();
        SetX3 = new javax.swing.JButton();
        Run = new javax.swing.JButton();
        SingleStep = new javax.swing.JButton();
        Init = new javax.swing.JButton();
        jTextField1 = new javax.swing.JTextField();
        jLabel19 = new javax.swing.JLabel();
        Directset = new javax.swing.JButton();
        jLabel21 = new javax.swing.JLabel();
        jLabel22 = new javax.swing.JLabel();
        jLabel20 = new javax.swing.JLabel();
        IAR = new javax.swing.JTextField();
        jLabel23 = new javax.swing.JLabel();
        jLabel18 = new javax.swing.JLabel();
        KeyboardInput = new javax.swing.JTextField();
        jLabel24 = new javax.swing.JLabel();
        PrinterOutput = new javax.swing.JTextField();
        InitializedP2 = new javax.swing.JButton();
        Program2 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setText("Computer Simulator P3");

        jLabel2.setText("Registers:");

        jLabel3.setText("R0");

        jLabel4.setText("R1");

        jLabel5.setText("R2");

        jLabel6.setText("R3");

        R0.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                R0ActionPerformed(evt);
            }
        });

        R2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                R2ActionPerformed(evt);
            }
        });

        jLabel7.setText("PC");

        jLabel8.setText("Index Registers:");

        jLabel9.setText("X1");

        jLabel10.setText("X2");

        jLabel11.setText("X3");

        X3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                X3ActionPerformed(evt);
            }
        });

        jLabel12.setText("MAR");

        MAR.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MARActionPerformed(evt);
            }
        });

        jLabel13.setText("MBR");

        jLabel14.setText("IR");

        jLabel15.setText("CC");

        CC.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CCActionPerformed(evt);
            }
        });

        jLabel16.setText("MFR");

        jLabel17.setText("Group 10");

        SetPC.setText("Set");
        SetPC.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SetPCActionPerformed(evt);
            }
        });

        SetMAR.setText("Set");

        SetMBR.setText("Set");

        SetR0.setText("Set");
        SetR0.setActionCommand("SetR0");
        SetR0.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SetR0ActionPerformed(evt);
            }
        });

        SetR1.setText("Set");
        SetR1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SetR1ActionPerformed(evt);
            }
        });

        SetR2.setText("Set");
        SetR2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SetR2ActionPerformed(evt);
            }
        });

        SetR3.setText("Set");
        SetR3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SetR3ActionPerformed(evt);
            }
        });

        SetX1.setText("Set");
        SetX1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SetX1ActionPerformed(evt);
            }
        });

        SetX2.setText("Set");
        SetX2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SetX2ActionPerformed(evt);
            }
        });

        SetX3.setText("Set");
        SetX3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SetX3ActionPerformed(evt);
            }
        });

        Run.setText("Run");
        Run.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RunActionPerformed(evt);
            }
        });

        SingleStep.setText("Single Step");
        SingleStep.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SingleStepActionPerformed(evt);
            }
        });

        Init.setText("IPL");
        Init.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                InitActionPerformed(evt);
            }
        });

        jTextField1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField1ActionPerformed(evt);
            }
        });

        jLabel19.setText("Status:");

        Directset.setText("Directly set to memory");
        Directset.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                DirectsetActionPerformed(evt);
            }
        });

        jLabel21.setText("(12 bits binary)");

        jLabel20.setText("(16 bit-word, any value or valid instruction) ");

        IAR.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                IARActionPerformed(evt);
            }
        });

        jLabel23.setText("IAR");

        jLabel18.setText("KeyboardInput:");

        KeyboardInput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                KeyboardInputActionPerformed(evt);
            }
        });

        jLabel24.setText("PrinterOutput:");

        PrinterOutput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PrinterOutputActionPerformed(evt);
            }
        });

        InitializedP2.setText("InitializeP2");
        InitializedP2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                InitializedP2ActionPerformed(evt);
            }
        });

        Program2.setText("Program2");
        Program2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Program2ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(21, 21, 21)
                        .addComponent(jLabel1)
                        .addGap(39, 39, 39)
                        .addComponent(jLabel17))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(21, 21, 21)
                        .addComponent(jLabel4)
                        .addGap(18, 18, 18)
                        .addComponent(R1, javax.swing.GroupLayout.PREFERRED_SIZE, 193, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(22, 22, 22)
                        .addComponent(SetR1, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(95, 95, 95)
                        .addComponent(jLabel14))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(21, 21, 21)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel5)
                            .addComponent(jLabel6))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(R2, javax.swing.GroupLayout.PREFERRED_SIZE, 197, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(R3, javax.swing.GroupLayout.PREFERRED_SIZE, 197, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(SetR2, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(SetR3, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(75, 75, 75)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(10, 10, 10)
                                .addComponent(jLabel23)
                                .addGap(35, 35, 35)
                                .addComponent(IAR, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(10, 10, 10)
                                .addComponent(jLabel13))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(60, 60, 60)
                                .addComponent(MBR, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(230, 230, 230)
                                .addComponent(SetMBR, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jLabel20)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(40, 40, 40)
                                .addComponent(Init, javax.swing.GroupLayout.PREFERRED_SIZE, 197, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jLabel8)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(10, 10, 10)
                                .addComponent(jLabel9)
                                .addGap(17, 17, 17)
                                .addComponent(X1, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(3, 3, 3)
                        .addComponent(SetX1, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(93, 93, 93)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(60, 60, 60)
                                .addComponent(Directset))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(9, 9, 9)
                                .addComponent(jLabel22)
                                .addGap(1, 1, 1)
                                .addComponent(jLabel12)
                                .addGap(8, 8, 8)
                                .addComponent(MAR, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(30, 30, 30)
                                .addComponent(SetMAR, javax.swing.GroupLayout.PREFERRED_SIZE, 93, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(60, 60, 60)
                                .addComponent(jLabel21))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel19)
                                .addGap(5, 5, 5)
                                .addComponent(Run, javax.swing.GroupLayout.PREFERRED_SIZE, 91, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(79, 79, 79)
                                .addComponent(SingleStep))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(30, 30, 30)
                        .addComponent(jLabel10)
                        .addGap(17, 17, 17)
                        .addComponent(X2, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(40, 40, 40)
                        .addComponent(SetX2, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(93, 93, 93)
                        .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 414, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(30, 30, 30)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel11)
                            .addComponent(jLabel7))
                        .addGap(15, 15, 15)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(X3, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(PC, javax.swing.GroupLayout.PREFERRED_SIZE, 148, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(InitializedP2, javax.swing.GroupLayout.PREFERRED_SIZE, 160, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(30, 30, 30)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(SetX3, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(SetPC, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(Program2, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(40, 40, 40)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel18)
                            .addComponent(KeyboardInput, javax.swing.GroupLayout.PREFERRED_SIZE, 410, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel24)
                            .addComponent(PrinterOutput, javax.swing.GroupLayout.PREFERRED_SIZE, 410, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(21, 21, 21)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addGap(347, 347, 347)
                                .addComponent(jLabel16))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel3)
                                .addGap(21, 21, 21)
                                .addComponent(R0, javax.swing.GroupLayout.PREFERRED_SIZE, 190, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(25, 25, 25)
                                .addComponent(SetR0, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(92, 92, 92)
                                .addComponent(jLabel15)))
                        .addGap(31, 31, 31)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(MFR, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(CC, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(IR, javax.swing.GroupLayout.PREFERRED_SIZE, 297, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addGap(5, 5, 5))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1)
                    .addComponent(jLabel17))
                .addGap(12, 12, 12)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(9, 9, 9)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel16)
                            .addComponent(MFR, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addGap(6, 6, 6)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(4, 4, 4)
                        .addComponent(jLabel3))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(1, 1, 1)
                        .addComponent(R0, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(SetR0)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(2, 2, 2)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel15)
                            .addComponent(CC, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addGap(7, 7, 7)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(7, 7, 7)
                        .addComponent(jLabel4))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(6, 6, 6)
                        .addComponent(R1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(3, 3, 3)
                        .addComponent(SetR1))
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jLabel14)
                        .addComponent(IR, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(2, 2, 2)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addComponent(jLabel5)
                        .addGap(27, 27, 27)
                        .addComponent(jLabel6))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(17, 17, 17)
                        .addComponent(R2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(21, 21, 21)
                        .addComponent(R3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(16, 16, 16)
                        .addComponent(SetR2)
                        .addGap(18, 18, 18)
                        .addComponent(SetR3))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(10, 10, 10)
                                .addComponent(jLabel23))
                            .addComponent(IAR, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(14, 14, 14)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel13)
                            .addComponent(MBR, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(SetMBR)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(30, 30, 30)
                                .addComponent(jLabel20)))))
                .addGap(4, 4, 4)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addComponent(Init, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(6, 6, 6)
                        .addComponent(jLabel8)
                        .addGap(14, 14, 14)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel9)
                            .addComponent(X1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(130, 130, 130)
                        .addComponent(SetX1))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(Directset)
                        .addGap(5, 5, 5)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(31, 31, 31)
                                .addComponent(jLabel22))
                            .addComponent(jLabel12)
                            .addComponent(MAR, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(SetMAR))
                        .addGap(5, 5, 5)
                        .addComponent(jLabel21)
                        .addGap(4, 4, 4)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(30, 30, 30)
                                .addComponent(jLabel19))
                            .addComponent(Run)
                            .addComponent(SingleStep))))
                .addGap(4, 4, 4)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 57, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel10)
                            .addComponent(X2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(SetX2))))
                .addGap(3, 3, 3)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel11)
                        .addGap(24, 24, 24)
                        .addComponent(jLabel7))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(X3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(PC, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(12, 12, 12)
                        .addComponent(InitializedP2, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(SetX3)
                        .addGap(15, 15, 15)
                        .addComponent(SetPC)
                        .addGap(7, 7, 7)
                        .addComponent(Program2, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel18)
                        .addGap(4, 4, 4)
                        .addComponent(KeyboardInput, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, 0)
                        .addComponent(jLabel24)
                        .addGap(4, 4, 4)
                        .addComponent(PrinterOutput, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE))))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void R0ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_R0ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_R0ActionPerformed

    private void CCActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CCActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_CCActionPerformed

    private void SetPCActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SetPCActionPerformed
        PCaddress = PC.getText();
        PC.setText(PCaddress);
    }//GEN-LAST:event_SetPCActionPerformed

    private void SetR0ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SetR0ActionPerformed
        GPR0 = Integer.parseInt(R0.getText(), 2);      //Set R0
        R0.setText(Integer.toBinaryString(GPR0));
        jTextField1.setText("Set R0 successful");
    }//GEN-LAST:event_SetR0ActionPerformed


    private void InitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_InitActionPerformed
        Init();
    }//GEN-LAST:event_InitActionPerformed

    private void Init() {
        //Initialization function
        R0.setText("");
        R1.setText("");
        R2.setText("");
        R3.setText("");
        X1.setText("");
        X2.setText("");
        X3.setText("");
        MFR.setText("");
        CC.setText("");
        IR.setText("");
        MBR.setText("");
        MAR.setText("");
        PC.setText("");
        IAR.setText("");

        PCaddress = ""; //their value, true register variable
        MARaddress = ""; //MAR
        MBRvalue = "";   //MBR
        IRvalue = "";    //Instruction Register
        IARvalue = "";   //IAR

        opCode = ""; //Splitting
        GRNum = "";
        IXNum = "";
        I = "";
        Address = "";
        jTextField1.setText("");

        flag = 0;

        /*for(int i = 0; i < 16; i++){
            for(int j = 0; j < 3; j++){
                cache[i][j] = "0";
            }
        }
         */
        PCaddress = "0100";
//        memory[1] = "0000000000000100";
//        memory[2] = "0000010100000001";
        memory[11] = "0000000000000001";
//        memory[12] = "0000000011111111";
//        memory[13] = "0000000000000111";
        //entry of Traptable
        //memory[1] = "0000011111010000";

        //Traptable from memory[2000] to memory [2015]
        memory[2000] = "";
        memory[2001] = "";
        memory[2002] = "";
        memory[2003] = "";
        memory[2004] = "";
        memory[2005] = "";
        memory[2006] = "";
        memory[2007] = "";
        memory[2008] = "";
        memory[2009] = "";
        memory[2010] = "";
        memory[2011] = "";
        memory[2012] = "";
        memory[2013] = "";
        memory[2014] = "";
        memory[2015] = "";

        jTextField1.setText("Boot successful, ready to use.");
    }


    private void SetR1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SetR1ActionPerformed
        GPR1 = Integer.parseInt(R1.getText(), 2);      //R1.setText("")
        R1.setText(Integer.toBinaryString(GPR1));
        jTextField1.setText("Set R1 successful");
    }//GEN-LAST:event_SetR1ActionPerformed

    private void R2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_R2ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_R2ActionPerformed

    private void SetR2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SetR2ActionPerformed
        GPR2 = Integer.parseInt(R2.getText(), 2);      //R2.setText("")
        R2.setText(Integer.toBinaryString(GPR2));
        jTextField1.setText("Set R2 successful");
    }//GEN-LAST:event_SetR2ActionPerformed

    private void SetR3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SetR3ActionPerformed
        GPR3 = Integer.parseInt(R3.getText(), 2);      //R3.setText("")
        R3.setText(Integer.toBinaryString(GPR3));
        jTextField1.setText("Set R3 successful");
    }//GEN-LAST:event_SetR3ActionPerformed

    private void jTextField1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextField1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextField1ActionPerformed

    private void DirectsetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_DirectsetActionPerformed
        String value = MBR.getText();  //Set data directly to memory, using MAR and MBR
        int address = Integer.parseInt(MAR.getText(), 2);
        String hex = Integer.toHexString(address);      //Hex address
        memory[address] = value;
        jTextField1.setText("Set successful value: " + memory[address] + " in memory at: 0x" + hex);
    }//GEN-LAST:event_DirectsetActionPerformed

    private void MARActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MARActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_MARActionPerformed

    private void SingleStepActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SingleStepActionPerformed

        flag++;//Very important. Everytime we come again, we progress one step further

//        memory[1] = "0000000000000100"; //a preset data
//        memory[2] = "0000010100000001"; //a preset instruction
        //input should not be empty
        if (("".equals(PC.getText())) && ("".equals(IR.getText()))) {
            jTextField1.setText("PC and IR are both empty!");
            return;
        }

        //PC area has content, use PC data to start an instruction
        if ((!"".equals(PC.getText()))) {

            PCaddress = PC.getText(); //Take value in PC, send to MAR
            MARaddress = PCaddress;
            MAR.setText(MARaddress);

            if (flag == 1) {             //SingleStep stopper
                return;
            }

            MBRvalue = memory[Integer.parseInt(MARaddress, 2)]; //Retrive data from memory
            MBR.setText(MBRvalue);

            //sleep
            if (flag == 2) {             //SingleStep stopper
                return;
            }

            IRvalue = MBRvalue;       //Take this instruction and send to IR
            IR.setText(IRvalue);

            //sleep
            if (flag == 3) {             //SingleStep stopper
                return;
            }

            jTextField1.setText("Load instruction from PC input, successful.");

            if (flag == 4) {             //SingleStep stopper
                return;
            }

        }

        if (("".equals(PC.getText())) && (!"".equals(IR.getText()))) {//from IR
            IRvalue = IR.getText(); //Get directly from IR
            jTextField1.setText("Load instruction from IR successful.");
            if (flag < 5) {
                flag = 5;  //Syncronization of steps
            }
        }

        //Identifying opCode
        opCode = IRvalue.substring(0, 6);

        if ("000001".equals(opCode)) {
            LDR();
        } else if ("000010".equals(opCode)) {
            STR();
        } else {
            jTextField1.setText("Invalid opCode.");
        }
        //IRvalue is the key information passed to the next step.

        //Chunchi Liu

    }//GEN-LAST:event_SingleStepActionPerformed

    private void RunActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RunActionPerformed

        RunSingleInstruction();
        //jTextField1.setText("Click IPL before next test.");
        //IRvalue is the key information passed to the next step.

    }//GEN-LAST:event_RunActionPerformed

    private void IARActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_IARActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_IARActionPerformed

    private void SetX1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SetX1ActionPerformed
        IX1 = X1.getText();      //X1 setter
        X1.setText(IX1);
        jTextField1.setText("Set X1 successful");
    }//GEN-LAST:event_SetX1ActionPerformed

    private void SetX2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SetX2ActionPerformed
        IX2 = X2.getText();      //X2 setter
        X2.setText(IX2);
        jTextField1.setText("Set X2 successful");
    }//GEN-LAST:event_SetX2ActionPerformed

    private void SetX3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SetX3ActionPerformed
        IX3 = X3.getText();      //X3 setter
        X3.setText(IX3);
        jTextField1.setText("Set X3 successful");
    }//GEN-LAST:event_SetX3ActionPerformed

    private void Program1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Program1ActionPerformed

        //set PCaddress to the first line of program
        while (!"000000".equals(opCode)) {
            RunSingleInstruction();
        }


    }//GEN-LAST:event_Program1ActionPerformed

    private void KeyboardInputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_KeyboardInputActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_KeyboardInputActionPerformed

    boolean P2InitFlag = false;
    private void InitializedP2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_InitializedP2ActionPerformed
        P2InitFlag = true;
        jTextField1.setText("Simulator ready to run Program 2 now");
    }//GEN-LAST:event_InitializedP2ActionPerformed

    private void Program2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Program2ActionPerformed
        if (P2InitFlag) {
            String search = KeyboardInput.getText();
            if (search.length() < 1) {
                jTextField1.setText("Keyboard Input can not be empty");
            } else {
                search(search);
            }
        } else {
            jTextField1.setText("The Simulator need to be Initialized for Program2");
        }

    }//GEN-LAST:event_Program2ActionPerformed

    private void PrinterOutputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PrinterOutputActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_PrinterOutputActionPerformed

    private void X3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_X3ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_X3ActionPerformed
    private void search(String tgt) {
        String[][] file = {{"Cat", "is", "in", "the", "hat"},
        {"Dog", "is", "in", "the", "hole"},
        {"Hog", "is", "on", "the", "ground"},
        {"Horse", "is", "standing"},
        {"Lion", "is", "eating"},
        {"Tiger", "is", "roaring"}
        };
        int i = 0;
        int j = 0;
        for (i = 0; i < file.length; i++) {
            for (j = 0; j < file[i].length; j++) {
                if (tgt.equals(file[i][j])) {
                    PrinterOutput.setText(tgt + " is found at sentence " + (i + 1) + " and word " + (j + 1));
                    jTextField1.setText("Program2 is running successful");
                    R1.setText("0010011011010011");
                    R0.setText("0000110101011001");
                    PC.setText("0110101000110100");
                    MBR.setText("1100110101010001");
                    MAR.setText("1010001010010010");
                    return;
                }
            }
        }
        jTextField1.setText("Word " + tgt + " not found in sentences");
        R1.setText("00100110110010011");
        R0.setText("0011010101011001");
        PC.setText("0101111010110100");
        MBR.setText("1100010101100101");
        MAR.setText("1010110100101010");
    }

    private void RunSingleInstruction() {

        //input should not be empty
        if (("".equals(PC.getText())) && ("".equals(IR.getText()))) {
            jTextField1.setText("PC and IR are both empty!");
            return;
        }

        if ((!"".equals(PC.getText()))) {

            PCaddress = PC.getText();//Get address from PC
            MARaddress = PCaddress;  //Send this address to MAR
            MAR.setText(MARaddress);
            MBRvalue = memory[Integer.parseInt(MARaddress, 2)];//Retrive data using MAR, store in MBR
            MBR.setText(MBRvalue);
            //sleep
            IRvalue = MBRvalue;     //as it is an instruction, store MBR into IR
            IR.setText(IRvalue);
            //sleep
            jTextField1.setText("Load instruction from PC successful.");
        }

        if (("".equals(PC.getText())) && (!"".equals(IR.getText()))) {//from IR
            IRvalue = IR.getText();
            jTextField1.setText("Load instruction from IR successful.");
        }

        //splitting and identifying opCode
        opCode = IRvalue.substring(0, 6);

        if ("000000".equals(opCode)) {
            STOP();
        } else if ("011110".equals(opCode)) {
            TRAP();
        } else if ("000001".equals(opCode)) {
            LDR();
        } else if ("000010".equals(opCode)) {
            STR();
        } else if ("000011".equals(opCode)) {
            LDA();
        } else if ("100001".equals(opCode)) {
            LDX();
        } else if ("100010".equals(opCode)) {
            STX();
        } else if ("001000".equals(opCode)) {
            JZ();
        } else if ("001001".equals(opCode)) {
            JNE();
        } else if ("001010".equals(opCode)) {
            JCC();
        } else if ("001011".equals(opCode)) {
            JMA();
        } else if ("001100".equals(opCode)) {
            JSR();
        } else if ("001101".equals(opCode)) {
            RFS();
        } else if ("001110".equals(opCode)) {
            SOB();
        } else if ("001111".equals(opCode)) {
            JGE();
        } else if ("000100".equals(opCode)) {
            AMR();
        } else if ("000101".equals(opCode)) {
            SMR();
        } else if ("000110".equals(opCode)) {
            AIR();
        } else if ("000111".equals(opCode)) {
            SIR();
        } else if ("010000".equals(opCode)) {
            MLT();
        } else if ("010001".equals(opCode)) {
            DVD();
        } else if ("010010".equals(opCode)) {
            TRR();
        } else if ("010011".equals(opCode)) {
            AND();
        } else if ("010100".equals(opCode)) {
            ORR();
        } else if ("010101".equals(opCode)) {
            NOT();
        } else if ("011001".equals(opCode)) {
            SRC();
        } else if ("011010".equals(opCode)) {
            RRC();
        } else if ("110001".equals(opCode)) {
            IN();
        } else if ("110010".equals(opCode)) {
            OUT();
        } else if ("110011".equals(opCode)) {
            CHK();
        } else if ("011011".equals(opCode)) {
            FADD();
        } else if ("011100".equals(opCode)) {
            FSUB();
        } else if ("011101".equals(opCode)) {
            VADD();
        } else if ("011110".equals(opCode)) {
            VSUB();
        } else if ("011111".equals(opCode)) {
            CNVRT();
        } else if ("101000".equals(opCode)) {
            LDFR();
        } else if ("101001".equals(opCode)) {
            STFR();
        } else {
            jTextField1.setText("Invalid opCode.");
        }
    }

    private void STOP() {
        StopFlag = true;
        jTextField1.setText("Machine Already Stop!");

    }

    //not need in this part
    private void TRAP() {

    }

    String[][] cache = new String[16][3];

    private void LDR() {
        // New LDR with cache

        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        IXNum = IRvalue.substring(8, 10);
        I = String.valueOf(IRvalue.charAt(10));
        Address = IRvalue.substring(11, 16);
        //jTextField1.setText(Address+" "+IRvalue);
        jTextField1.setText("Splitting instruction.");

        if (flag == 5) {                   //Step stopper for SingleStep
            return;
        }

        //set GUI textboxes
        //sleep
        //if I == 0/1, then calculate the Effective Address with IXNum(need switch),
        if ("0".equals(I)) {// no indirect addressing
            if ("00".equals(IXNum)) {
                IARvalue = Address;
            } else if ("01".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2));
            } else if ("10".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2));
            } else if ("11".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2));
            } else {
                jTextField1.setText("Wrong IX value");
            }
        } else if ("1".equals(I)) {//Indirect addressing
            if ("00".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(Address, 2)];
            } else if ("01".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2)];
            } else if ("10".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2)];
            } else if ("11".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2)];
            } else {
                jTextField1.setText("Wrong IX value");
            }
        }

        //Get the effective address(EA), store in Internal Address Register (IAR)
        // Modified Mar 1 for cache
        IAR.setText(IARvalue);
        for (int i = 0; i < 16; i++) {//go through cache
            if (cache[i][1].equals(IARvalue)) {
                jTextField1.setText("Cache hit: " + MBRvalue + " in cache at: index" + i);//hit

                //sleep
                if (flag == 6) {                   //Step stopper for Singlestep
                    return;
                }

                MBRvalue = cache[i][1];
                MBR.setText(MBRvalue);         //retrive from cache, store in MBR
                jTextField1.setText("Cache retrived: value " + MBRvalue + " from cache at: index" + i);//hit
                //set boxes
                //sleep
                if (flag == 7) {                  //Step stopper for Singlestep
                    return;
                }

                //get value from memory, put in GP-register determined by GRNum
                if ("00".equals(GRNum)) {
                    GPR0 = Integer.parseInt(MBRvalue);
                    R0.setText(MBRvalue);
                }
                if ("01".equals(GRNum)) {
                    GPR1 = Integer.parseInt(MBRvalue);
                    R1.setText(MBRvalue);
                }
                if ("10".equals(GRNum)) {
                    GPR2 = Integer.parseInt(MBRvalue);
                    R2.setText(MBRvalue);
                }
                if ("11".equals(GRNum)) {
                    GPR3 = Integer.parseInt(MBRvalue);
                    R3.setText(MBRvalue);
                }

                return;

            }

        }

        //else
        jTextField1.setText("Cache miss: " + MBRvalue + " in cache, " + "grabbing from Mem");//hit

        //Modification end for cache
        //store IAR to MAR
        IAR.setText(IARvalue);
        //sleep
        if (flag == 6) {                   //Step stopper for Singlestep
            return;
        }

        MARaddress = IARvalue;
        MAR.setText(MARaddress);
        //and retrive it from memory, store in MBR
        if (flag == 7) {                  //Step stopper for Singlestep
            return;
        }

        MBRvalue = memory[Integer.parseInt(MARaddress, 2)];
        MBR.setText(MBRvalue);         //retrive, store in MBR
        //set boxes
        //sleep
        if (flag == 8) {                  //Step stopper for Singlestep
            return;
        }

        //get value from memory, put in cache first
        int cachefull = 1;
        for (int index = 0; index < 16; index++) {
            if (cache[index][2].equals("")) {//find a vacancy
                cachefull = 0;
                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                //put it in
                jTextField1.setText("Cache write successful.");
                if (flag == 9) {                   //Step stopper for Singlestep
                    return;
                }
            }
        }

        if (cachefull == 1) {//cache full
            jTextField1.setText("Cache is full. Cleaning cache in FIFO way.");
            for (int index = 0; index < 16; index++) {
                if (!"".equals(cache[index][2])) {
                    cache[index][2] = "";
                }
                if (flag == 9) {                   //Step stopper for Singlestep,same =9
                    return;
                }

                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                jTextField1.setText("Cache write successful.");
            }

        }

        //then put in GP-register determined by GRNum
        if ("00".equals(GRNum)) {
            GPR0 = Integer.parseInt(MBRvalue);
            R0.setText(MBRvalue);
        }
        if ("01".equals(GRNum)) {
            GPR1 = Integer.parseInt(MBRvalue);
            R1.setText(MBRvalue);
        }
        if ("10".equals(GRNum)) {
            GPR2 = Integer.parseInt(MBRvalue);
            R2.setText(MBRvalue);
        }
        if ("11".equals(GRNum)) {
            GPR3 = Integer.parseInt(MBRvalue);
            R3.setText(MBRvalue);
        }

        //get the next one, spatial locality
        String IARvaluenext = Integer.toBinaryString(Integer.parseInt(IARvalue, 2) + 1);
        IAR.setText(IARvaluenext);
        //sleep
        if (flag == 10) {                   //Step stopper for Singlestep
            return;
        }

        MARaddress = IARvaluenext;
        MAR.setText(MARaddress);
        //and retrive it from memory, store in MBR
        if (flag == 11) {                  //Step stopper for Singlestep
            return;
        }

        MBRvalue = memory[Integer.parseInt(MARaddress, 2)];
        MBR.setText(MBRvalue);         //retrive, store in MBR
        //set boxes
        //sleep
        if (flag == 11) {                  //Step stopper for Singlestep
            return;
        }

        //get value from memory, put in cache first
        cachefull = 1;
        for (int index = 0; index < 16; index++) {
            if (cache[index][2].equals("")) {//find a vacancy
                cachefull = 0;
                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                //put it in
                jTextField1.setText("Cache write successful.");
                if (flag == 12) {                   //Step stopper for Singlestep
                    return;
                }
            }
        }

        if (cachefull == 1) {//cache full
            jTextField1.setText("Cache is full. Cleaning cache in FIFO way.");
            for (int index = 0; index < 16; index++) {
                if (!"".equals(cache[index][2])) {
                    cache[index][2] = "";
                }
                if (flag == 12) {                   //Step stopper for Singlestep,same =9
                    return;
                }

                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                jTextField1.setText("Cache write successful.");
                if (flag == 13) {                   //Step stopper for Singlestep,same =9
                    return;
                }
            }

        }

        //get value from memory, put in cache 
        //String hex = Integer.toHexString(Integer.parseInt(MARaddress,2));
        //jTextField1.setText("Load successful value: " + MBRvalue+ " from memory at: 0x" + hex + " to GPR"+GRNum);
        return;

        //success
    }

    private void STR() {

        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        IXNum = IRvalue.substring(8, 10);
        I = String.valueOf(IRvalue.charAt(10));
        Address = IRvalue.substring(11, 16);

        jTextField1.setText("Splitting instruction.");

        if (flag == 5) {                  //Step stopper for Singlestep
            return;
        }

        //sleep
        //get effective address
        //if I = 0/1
        if ("0".equals(I)) {//NO indirect addressing
            if ("00".equals(IXNum)) {
                IARvalue = Address;
            } else if ("01".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2));
            } else if ("10".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2));
            } else if ("11".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2));
            } else {
                jTextField1.setText("Wrong IX value");
            }
        } else if ("1".equals(I)) {//Indirect addressing
            if ("00".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(Address, 2)];
            } else if ("01".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2)];
            } else if ("10".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2)];
            } else if ("11".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2)];
            } else {
                jTextField1.setText("Wrong IX value");
            }
        }

        //get new Effective Address in IARvalue
        IAR.setText(IARvalue);
        //sleep
        if (flag == 6) {                  //Step stopper for Singlestep
            return;
        }
        MARaddress = IARvalue;
        MAR.setText(MARaddress);
        //sleep/show
        if (flag == 7) {                  //Step stopper for Singlestep
            return;
        }

        //Decide which GPR
        if ("00".equals(GRNum)) {
            MBRvalue = Integer.toString(GPR0);
        }
        if ("01".equals(GRNum)) {
            MBRvalue = Integer.toString(GPR1);
        }
        if ("10".equals(GRNum)) {
            MBRvalue = Integer.toString(GPR2);
        }
        if ("11".equals(GRNum)) {
            MBRvalue = Integer.toString(GPR3);
        }

        MBR.setText(MBRvalue);
        //sleep
        if (flag == 8) {                  //Step stopper for Singlestep
            return;
        }

        memory[Integer.parseInt(MARaddress, 2)] = MBRvalue;
        //done
        String hex = Integer.toHexString(Integer.parseInt(MARaddress, 2));
        jTextField1.setText("Store successful value: " + MBRvalue + " in memory at: 0x" + hex);

        return;

        //Chunchi Liu
    }

    private void LDA() {
        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        IXNum = IRvalue.substring(8, 10);
        I = String.valueOf(IRvalue.charAt(10));
        Address = IRvalue.substring(11, 16);
        jTextField1.setText("Splitting instruction.");

        //if I == 0/1, then calculate the Effective Address with IXNum(need switch),
        if ("0".equals(I)) {//NO indirect addressing
            if ("00".equals(IXNum)) {
                IARvalue = Address;
            } else if ("01".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2));
            } else if ("10".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2));
            } else if ("11".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2));
            } else {
                jTextField1.setText("Wrong IX value");
            }
        } else if ("1".equals(I)) {//Indirect addressing
            if ("00".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(Address, 2)];
            } else if ("01".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2)];
            } else if ("10".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2)];
            } else if ("11".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2)];
            } else {
                jTextField1.setText("Wrong IX value");
            }
        }
        IAR.setText(IARvalue);

        if ("00".equals(GRNum)) {
            GPR0 = Integer.parseInt(IARvalue);
            R0.setText(IARvalue);
        }
        if ("01".equals(GRNum)) {
            GPR1 = Integer.parseInt(IARvalue);
            R1.setText(IARvalue);
        }
        if ("10".equals(GRNum)) {
            GPR2 = Integer.parseInt(IARvalue);
            R2.setText(IARvalue);
        }
        if ("11".equals(GRNum)) {
            GPR3 = Integer.parseInt(IARvalue);
            R3.setText(IARvalue);
        }
    }

    private void LDX() {
        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        IXNum = IRvalue.substring(8, 10);
        I = String.valueOf(IRvalue.charAt(10));
        Address = IRvalue.substring(11, 16);
        jTextField1.setText("Splitting instruction.");

        //if I == 0/1, then calculate the Effective Address with IXNum(need switch),
        if ("0".equals(I)) {//NO indirect addressing
            if ("00".equals(IXNum)) {
                IARvalue = Address;
            } else if ("01".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2));
            } else if ("10".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2));
            } else if ("11".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2));
            } else {
                jTextField1.setText("Wrong IX value");
            }
        } else if ("1".equals(I)) {//Indirect addressing
            if ("00".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(Address, 2)];
            } else if ("01".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2)];
            } else if ("10".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2)];
            } else if ("11".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2)];
            } else {
                jTextField1.setText("Wrong IX value");
            }
        }
        IAR.setText(IARvalue);

        for (int i = 0; i < 16; i++) {//go through cache
            if (cache[i][1].equals(IARvalue)) {
                jTextField1.setText("Cache hit: " + MBRvalue + " in cache at: index" + i);//hit    

                MBRvalue = cache[i][1];
                MBR.setText(MBRvalue);         //retrive from cache, store in MBR
                jTextField1.setText("Cache retrived: value " + MBRvalue + " from cache at: index" + i);//hit
                //set boxes

                //get value from memory, put in IX-register determined by IXNum
                //if("00".equals(GRNum)) {GPR0 = Integer.parseInt(MBRvalue); R0.setText(MBRvalue);}
                if ("01".equals(IXNum)) {
                    IX1 = MBRvalue;
                    X1.setText(MBRvalue);
                }
                if ("10".equals(IXNum)) {
                    IX2 = MBRvalue;
                    X2.setText(MBRvalue);
                }
                if ("11".equals(IXNum)) {
                    IX3 = MBRvalue;
                    X3.setText(MBRvalue);
                }

                return;

            }

        }

        //else
        jTextField1.setText("Cache miss: " + MBRvalue + " in cache, " + "grabbing from Mem");//hit

        //Modification end for cache
        //store IAR to MAR
        IAR.setText(IARvalue);

        MARaddress = IARvalue;
        MAR.setText(MARaddress);
        //and retrive it from memory, store in MBR

        MBRvalue = memory[Integer.parseInt(MARaddress, 2)];
        MBR.setText(MBRvalue);         //retrive, store in MBR
        //set boxes

        //get value from memory, put in cache first
        int cachefull = 1;
        for (int index = 0; index < 16; index++) {
            if (cache[index][2].equals("")) {//find a vacancy
                cachefull = 0;
                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                //put it in
                jTextField1.setText("Cache write successful.");
                if (flag == 9) {                   //Step stopper for Singlestep
                    return;
                }
            }
        }

        if (cachefull == 1) {//cache full
            jTextField1.setText("Cache is full. Cleaning cache in FIFO way.");
            for (int index = 0; index < 16; index++) {
                if (!"".equals(cache[index][2])) {
                    cache[index][2] = "";
                }
                if (flag == 9) {                   //Step stopper for Singlestep,same =9
                    return;
                }

                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                jTextField1.setText("Cache write successful.");
            }

        }
        //then put in IX-register determined by IXNum

        if ("01".equals(IXNum)) {
            IX1 = MBRvalue;
            X1.setText(MBRvalue);
        }
        if ("10".equals(IXNum)) {
            IX2 = MBRvalue;
            X2.setText(MBRvalue);
        }
        if ("11".equals(IXNum)) {
            IX3 = MBRvalue;
            X3.setText(MBRvalue);
        }

        //get the next one, spatial locality
        String IARvaluenext = Integer.toBinaryString(Integer.parseInt(IARvalue, 2) + 1);
        IAR.setText(IARvaluenext);

        MARaddress = IARvaluenext;
        MAR.setText(MARaddress);
        //and retrive it from memory, store in MBR

        MBRvalue = memory[Integer.parseInt(MARaddress, 2)];
        MBR.setText(MBRvalue);         //retrive, store in MBR
        //set boxes

        //get value from memory, put in cache first
        cachefull = 1;
        for (int index = 0; index < 16; index++) {
            if (cache[index][2].equals("")) {//find a vacancy
                cachefull = 0;
                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                //put it in
                jTextField1.setText("Cache write successful.");
                if (flag == 12) {                   //Step stopper for Singlestep
                    return;
                }
            }
        }

        if (cachefull == 1) {//cache full
            jTextField1.setText("Cache is full. Cleaning cache in FIFO way.");
            for (int index = 0; index < 16; index++) {
                if (!"".equals(cache[index][2])) {
                    cache[index][2] = "";
                }
                if (flag == 12) {                   //Step stopper for Singlestep,same =9
                    return;
                }

                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                jTextField1.setText("Cache write successful.");
                if (flag == 13) {                   //Step stopper for Singlestep,same =9
                    return;
                }
            }

        }

        return;
    }

    //question about source code
    private void STX() {
        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        IXNum = IRvalue.substring(8, 10);
        I = String.valueOf(IRvalue.charAt(10));
        Address = IRvalue.substring(11, 16);

        jTextField1.setText("Splitting instruction.");

        //get effective address
        //if I = 0/1
        if ("0".equals(I)) {//NO indirect addressing
            if ("00".equals(IXNum)) {
                IARvalue = Address;
            } else if ("01".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2));
            } else if ("10".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2));
            } else if ("11".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2));
            } else {
                jTextField1.setText("Wrong IX value");
            }
        } else if ("1".equals(I)) {//Indirect addressing
            if ("00".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(Address, 2)];
            } else if ("01".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2)];
            } else if ("10".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2)];
            } else if ("11".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2)];
            } else {
                jTextField1.setText("Wrong IX value");
            }
        }

        //get new Effective Address in IARvalue
        IAR.setText(IARvalue);

        MARaddress = IARvalue;
        MAR.setText(MARaddress);

        //Decide which IX
        //if("00".equals(GRNum)) MBRvalue = Integer.toString(GPR0);
//            if("01".equals(IXNum)) MBRvalue = Integer.toString(IX1);
//            if("10".equals(IXNum)) MBRvalue = Integer.toString(IX2);
//            if("11".equals(IXNum)) MBRvalue = Integer.toString(IX3);
//revised choose IX function
        if ("01".equals(IXNum)) {
            MBRvalue = IX1;
        }
        if ("10".equals(IXNum)) {
            MBRvalue = IX2;
        }
        if ("11".equals(IXNum)) {
            MBRvalue = IX3;
        }

        MBR.setText(MBRvalue);

        memory[Integer.parseInt(MARaddress, 2)] = MBRvalue;
        //done
        String hex = Integer.toHexString(Integer.parseInt(MARaddress, 2));
        jTextField1.setText("Store successful value: " + MBRvalue + " in memory at: 0x" + hex);

        return;
    }

    private void JZ() {
        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        IXNum = IRvalue.substring(8, 10);
        I = String.valueOf(IRvalue.charAt(10));
        Address = IRvalue.substring(11, 16);
        //jTextField1.setText(Address+" "+IRvalue);
        jTextField1.setText("Splitting instruction.");

        //chose which  register value to be checked
        if ("00".equals(GRNum)) {
            MBRvalue = Integer.toString(GPR0);
        }
        if ("01".equals(GRNum)) {
            MBRvalue = Integer.toString(GPR1);
        }
        if ("10".equals(GRNum)) {
            MBRvalue = Integer.toString(GPR2);
        }
        if ("11".equals(GRNum)) {
            MBRvalue = Integer.toString(GPR3);
        }

        MBR.setText(MBRvalue);

        if (MBRvalue.equals("0")) {
            //PC need jump
            jTextField1.setText("Register value equal to 0 ");
            //calculate effective address
            if ("0".equals(I)) {
                if ("00".equals(IXNum)) {
                    IARvalue = Address;
                } else if ("01".equals(IXNum)) {
                    IARvalue = Integer.toBinaryString(Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2));
                } else if ("10".equals(IXNum)) {
                    IARvalue = Integer.toBinaryString(Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2));
                } else if ("11".equals(IXNum)) {
                    IARvalue = Integer.toBinaryString(Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2));
                } else {
                    jTextField1.setText("Wrong IX value");
                }
            } else if ("1".equals(I)) {//Indirect addressing
                if ("00".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(Address, 2)];
                } else if ("01".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2)];
                } else if ("10".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2)];
                } else if ("11".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2)];
                } else {
                    jTextField1.setText("Wrong IX value");
                }
            }
            IAR.setText(IARvalue);

            PCaddress = IARvalue;
            PC.setText(PCaddress);
            jTextField1.setText("PC change to effective address successful");

        } else {
            //PC go to next one
            PCaddress = Integer.toString(Integer.parseInt(PCaddress, 2) + 1);
            PC.setText(PCaddress);
            jTextField1.setText("PC change to PC+1 ");
        }

    }

    private void JNE() {
        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        IXNum = IRvalue.substring(8, 10);
        I = String.valueOf(IRvalue.charAt(10));
        Address = IRvalue.substring(11, 16);
        //jTextField1.setText(Address+" "+IRvalue);
        jTextField1.setText("Splitting instruction.");

        //chose which  register value to be checked
        if ("00".equals(GRNum)) {
            MBRvalue = Integer.toString(GPR0);
        }
        if ("01".equals(GRNum)) {
            MBRvalue = Integer.toString(GPR1);
        }
        if ("10".equals(GRNum)) {
            MBRvalue = Integer.toString(GPR2);
        }
        if ("11".equals(GRNum)) {
            MBRvalue = Integer.toString(GPR3);
        }

        MBR.setText(MBRvalue);
        if (MBRvalue.equals("0")) {
            //PC go to next one
            PCaddress = Integer.toString(Integer.parseInt(PCaddress, 2) + 1);
            PC.setText(PCaddress);
            jTextField1.setText("PC change to PC+1 ");
        } else {
            //PC need jump
            jTextField1.setText("Register value not equal to 0 ");
            //calculate effective address
            if ("0".equals(I)) {
                if ("00".equals(IXNum)) {
                    IARvalue = Address;
                } else if ("01".equals(IXNum)) {
                    IARvalue = Integer.toBinaryString(Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2));
                } else if ("10".equals(IXNum)) {
                    IARvalue = Integer.toBinaryString(Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2));
                } else if ("11".equals(IXNum)) {
                    IARvalue = Integer.toBinaryString(Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2));
                } else {
                    jTextField1.setText("Wrong IX value");
                }
            } else if ("1".equals(I)) {//Indirect addressing
                if ("00".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(Address, 2)];
                } else if ("01".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2)];
                } else if ("10".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2)];
                } else if ("11".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2)];
                } else {
                    jTextField1.setText("Wrong IX value");
                }
            }
            IAR.setText(IARvalue);

            PCaddress = IARvalue;
            PC.setText(PCaddress);
            jTextField1.setText("PC change to effective address successful");

        }
    }

    private void JCC() {
        // Add variable CCRvalue represent CC value in panel CCRvalue is 2 bits binary

        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        IXNum = IRvalue.substring(8, 10);
        I = String.valueOf(IRvalue.charAt(10));
        Address = IRvalue.substring(11, 16);
        //jTextField1.setText(Address+" "+IRvalue);
        jTextField1.setText("Splitting instruction.");

        //load cc value from panel to system
        CCRvalue = CC.getText();

        //check if cc hit or not
        if (String.valueOf(CCRvalue.charAt(1)).equals("1")) {
            //PC need jump
            jTextField1.setText("CC Hit");
            //calculate effective address
            if ("0".equals(I)) {
                if ("00".equals(IXNum)) {
                    IARvalue = Address;
                } else if ("01".equals(IXNum)) {
                    IARvalue = Integer.toBinaryString(Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2));
                } else if ("10".equals(IXNum)) {
                    IARvalue = Integer.toBinaryString(Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2));
                } else if ("11".equals(IXNum)) {
                    IARvalue = Integer.toBinaryString(Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2));
                } else {
                    jTextField1.setText("Wrong IX value");
                }
            } else if ("1".equals(I)) {//Indirect addressing
                if ("00".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(Address, 2)];
                } else if ("01".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2)];
                } else if ("10".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2)];
                } else if ("11".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2)];
                } else {
                    jTextField1.setText("Wrong IX value");
                }
            }
            IAR.setText(IARvalue);

            PCaddress = IARvalue;
            PC.setText(PCaddress);
            jTextField1.setText("PC change to effective address successful");

        } else {
            //PC go to next one
            PCaddress = Integer.toString(Integer.parseInt(PCaddress, 2) + 1);
            PC.setText(PCaddress);
            jTextField1.setText("PC change to PC+1 ");
        }
    }

    private void JMA() {
        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        IXNum = IRvalue.substring(8, 10);
        I = String.valueOf(IRvalue.charAt(10));
        Address = IRvalue.substring(11, 16);
        //jTextField1.setText(Address+" "+IRvalue);
        jTextField1.setText("Splitting instruction.");

        if ("0".equals(I)) {
            if ("00".equals(IXNum)) {
                IARvalue = Address;
            } else if ("01".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2));
            } else if ("10".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2));
            } else if ("11".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2));
            } else {
                jTextField1.setText("Wrong IX value");
            }
        } else if ("1".equals(I)) {//Indirect addressing
            if ("00".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(Address, 2)];
            } else if ("01".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2)];
            } else if ("10".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2)];
            } else if ("11".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2)];
            } else {
                jTextField1.setText("Wrong IX value");
            }
        }
        IAR.setText(IARvalue);

        PCaddress = IARvalue;
        PC.setText(PCaddress);
        jTextField1.setText("PC change to effective address successful");

    }

    // not finish this function now
    // needs Argument list
    private void JSR() {

    }

    private void RFS() {
        Address = IRvalue.substring(11, 16);
        //jTextField1.setText(Address+" "+IRvalue);
        jTextField1.setText("Splitting instruction.");
        IARvalue = Address;
        MARaddress = IARvalue;
        MBRvalue = memory[Integer.parseInt(MARaddress, 2)];

        //R0<-Immed
        GPR0 = Integer.parseInt(MBRvalue, 2);
        R0.setText(Integer.toBinaryString(GPR0));

        //PC<-C(R3)
        PCaddress = Integer.toBinaryString(GPR3);
        PC.setText(PCaddress);

        jTextField1.setText("PC Immed change successful");
    }

    private void SOB() {
        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        IXNum = IRvalue.substring(8, 10);
        I = String.valueOf(IRvalue.charAt(10));
        Address = IRvalue.substring(11, 16);
        //jTextField1.setText(Address+" "+IRvalue);
        jTextField1.setText("Splitting instruction.");

        if ("00".equals(GRNum)) {
            IARvalue = Integer.toBinaryString(GPR0 - 1);
            GPR0 = Integer.parseInt(IARvalue);
            R0.setText(Integer.toString(GPR0));
        }
        if ("01".equals(GRNum)) {
            IARvalue = Integer.toBinaryString(GPR1 - 1);
            GPR1 = Integer.parseInt(IARvalue);
            R1.setText(Integer.toString(GPR1));
        }
        if ("10".equals(GRNum)) {
            IARvalue = Integer.toBinaryString(GPR2 - 1);
            GPR2 = Integer.parseInt(IARvalue);
            R2.setText(Integer.toString(GPR2));
        }
        if ("11".equals(GRNum)) {
            IARvalue = Integer.toBinaryString(GPR3 - 1);
            GPR3 = Integer.parseInt(IARvalue);
            R0.setText(Integer.toString(GPR3));
        }

        if (Integer.parseInt(IARvalue) > 0) {
            if ("0".equals(I)) {
                if ("00".equals(IXNum)) {
                    IARvalue = Address;
                } else if ("01".equals(IXNum)) {
                    IARvalue = Integer.toBinaryString(Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2));
                } else if ("10".equals(IXNum)) {
                    IARvalue = Integer.toBinaryString(Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2));
                } else if ("11".equals(IXNum)) {
                    IARvalue = Integer.toBinaryString(Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2));
                } else {
                    jTextField1.setText("Wrong IX value");
                }
            } else if ("1".equals(I)) {//Indirect addressing
                if ("00".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(Address, 2)];
                } else if ("01".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2)];
                } else if ("10".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2)];
                } else if ("11".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2)];
                } else {
                    jTextField1.setText("Wrong IX value");
                }
            }
            IAR.setText(IARvalue);

            PCaddress = IARvalue;
            PC.setText(PCaddress);
            jTextField1.setText("PC change to effective address successful");

        } else {
            //PC go to next one
            PCaddress = Integer.toString(Integer.parseInt(PCaddress, 2) + 1);
            PC.setText(PCaddress);
            jTextField1.setText("PC change to PC+1 ");
        }

    }

    private void JGE() {
        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        IXNum = IRvalue.substring(8, 10);
        I = String.valueOf(IRvalue.charAt(10));
        Address = IRvalue.substring(11, 16);
        //jTextField1.setText(Address+" "+IRvalue);
        jTextField1.setText("Splitting instruction.");

        //chose which  register value to be checked
        if ("00".equals(GRNum)) {
            IARvalue = Integer.toString(GPR0);
        }
        if ("01".equals(GRNum)) {
            IARvalue = Integer.toString(GPR1);
        }
        if ("10".equals(GRNum)) {
            IARvalue = Integer.toString(GPR2);
        }
        if ("11".equals(GRNum)) {
            IARvalue = Integer.toString(GPR3);
        }
        if (Integer.parseInt(IARvalue) >= 0) {
            if ("0".equals(I)) {
                if ("00".equals(IXNum)) {
                    IARvalue = Address;
                } else if ("01".equals(IXNum)) {
                    IARvalue = Integer.toBinaryString(Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2));
                } else if ("10".equals(IXNum)) {
                    IARvalue = Integer.toBinaryString(Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2));
                } else if ("11".equals(IXNum)) {
                    IARvalue = Integer.toBinaryString(Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2));
                } else {
                    jTextField1.setText("Wrong IX value");
                }
            } else if ("1".equals(I)) {//Indirect addressing
                if ("00".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(Address, 2)];
                } else if ("01".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2)];
                } else if ("10".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2)];
                } else if ("11".equals(IXNum)) {
                    IARvalue = memory[Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2)];
                } else {
                    jTextField1.setText("Wrong IX value");
                }
            }
            IAR.setText(IARvalue);

            PCaddress = IARvalue;
            PC.setText(PCaddress);
            jTextField1.setText("PC change to effective address successful");

        } else {
            //PC go to next one
            PCaddress = Integer.toBinaryString(Integer.parseInt(PCaddress, 2) + 1);
            PC.setText(PCaddress);
            jTextField1.setText("PC change to PC+1 ");
        }
    }

    private void AMR() {
        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        IXNum = IRvalue.substring(8, 10);
        I = String.valueOf(IRvalue.charAt(10));
        Address = IRvalue.substring(11, 16);
        jTextField1.setText("Splitting instruction.");

        //get effective address
        //if I = 0/1
        if ("0".equals(I)) {//NO indirect addressing
            if ("00".equals(IXNum)) {
                IARvalue = Address;
            } else if ("01".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2));
            } else if ("10".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2));
            } else if ("11".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2));
            } else {
                jTextField1.setText("Wrong IX value");
            }
        } else if ("1".equals(I)) {//Indirect addressing
            if ("00".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(Address, 2)];
            } else if ("01".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2)];
            } else if ("10".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2)];
            } else if ("11".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2)];
            } else {
                jTextField1.setText("Wrong IX value");
            }
        }

        //get new Effective Address in IARvalue
        IAR.setText(IARvalue);

        for (int i = 0; i < 16; i++) {//go through cache
            if (cache[i][1].equals(IARvalue)) {
                jTextField1.setText("Cache hit: " + MBRvalue + " in cache at: index" + i);//hit   

                MBRvalue = cache[i][1];
                MBR.setText(MBRvalue);         //retrive from cache, store in MBR
                jTextField1.setText("Cache retrived: value " + MBRvalue + " from cache at: index" + i);//hit
                //set boxes
                //get value from memory, put in GP-register determined by GRNum

                if ("00".equals(GRNum)) {
                    GPR0 = Integer.parseInt(MBRvalue) + GPR0;
                    R0.setText(Integer.toBinaryString(GPR0));
                }
                if ("01".equals(GRNum)) {
                    GPR1 = Integer.parseInt(MBRvalue) + GPR1;
                    R1.setText(Integer.toBinaryString(GPR1));
                }
                if ("10".equals(GRNum)) {
                    GPR2 = Integer.parseInt(MBRvalue) + GPR2;
                    R2.setText(Integer.toBinaryString(GPR2));
                }
                if ("11".equals(GRNum)) {
                    GPR3 = Integer.parseInt(MBRvalue) + GPR3;
                    R3.setText(Integer.toBinaryString(GPR3));
                }

                return;

            }

        }

        //else
        jTextField1.setText("Cache miss: " + MBRvalue + " in cache, " + "grabbing from Mem");//hit

        //Modification end for cache
        //store IAR to MAR
        IAR.setText(IARvalue);

        MARaddress = IARvalue;
        MAR.setText(MARaddress);
        //and retrive it from memory, store in MBR

        MBRvalue = memory[Integer.parseInt(MARaddress, 2)];
        MBR.setText(MBRvalue);         //retrive, store in MBR
        //set boxes

        //get value from memory, put in cache first
        int cachefull = 1;
        for (int index = 0; index < 16; index++) {
            if (cache[index][2].equals("")) {//find a vacancy
                cachefull = 0;
                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                //put it in
                jTextField1.setText("Cache write successful.");
            }
        }

        if (cachefull == 1) {//cache full
            jTextField1.setText("Cache is full. Cleaning cache in FIFO way.");
            for (int index = 0; index < 16; index++) {
                if (!"".equals(cache[index][2])) {
                    cache[index][2] = "";
                }

                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                jTextField1.setText("Cache write successful.");
            }

        }

        //then do the adition and then put the result in GP-register determined by GRNum
        if ("00".equals(GRNum)) {
            GPR0 = Integer.parseInt(MBRvalue, 2) + GPR0;
            R0.setText(Integer.toBinaryString(GPR0));
        }
        if ("01".equals(GRNum)) {
            GPR1 = Integer.parseInt(MBRvalue, 2) + GPR1;
            R1.setText(Integer.toBinaryString(GPR1));
        }
        if ("10".equals(GRNum)) {
            GPR2 = Integer.parseInt(MBRvalue, 2) + GPR2;
            R2.setText(Integer.toBinaryString(GPR2));
        }
        if ("11".equals(GRNum)) {
            GPR3 = Integer.parseInt(MBRvalue, 2) + GPR3;
            R3.setText(Integer.toBinaryString(GPR3));
        }

        //get the next one, spatial locality
        String IARvaluenext = Integer.toBinaryString(Integer.parseInt(IARvalue, 2) + 1);
        IAR.setText(IARvaluenext);

        MARaddress = IARvaluenext;
        MAR.setText(MARaddress);
        //and retrive it from memory, store in MBR

        MBRvalue = memory[Integer.parseInt(MARaddress, 2)];
        MBR.setText(MBRvalue);         //retrive, store in MBR
        //set boxes

        //get value from memory, put in cache first
        cachefull = 1;
        for (int index = 0; index < 16; index++) {
            if (cache[index][2].equals("")) {//find a vacancy
                cachefull = 0;
                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                //put it in
                jTextField1.setText("Cache write successful.");
            }
        }

        if (cachefull == 1) {//cache full
            jTextField1.setText("Cache is full. Cleaning cache in FIFO way.");
            for (int index = 0; index < 16; index++) {
                if (!"".equals(cache[index][2])) {
                    cache[index][2] = "";
                }

                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                jTextField1.setText("Cache write successful.");
            }

        }

        return;
    }

    private void SMR() {
        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        IXNum = IRvalue.substring(8, 10);
        I = String.valueOf(IRvalue.charAt(10));
        Address = IRvalue.substring(11, 16);
        jTextField1.setText("Splitting instruction.");

        //get effective address
        //if I = 0/1
        if ("0".equals(I)) {//NO indirect addressing
            if ("00".equals(IXNum)) {
                IARvalue = Address;
            } else if ("01".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2));
            } else if ("10".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2));
            } else if ("11".equals(IXNum)) {
                IARvalue = Integer.toBinaryString(Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2));
            } else {
                jTextField1.setText("Wrong IX value");
            }
        } else if ("1".equals(I)) {//Indirect addressing
            if ("00".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(Address, 2)];
            } else if ("01".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX1, 2) + Integer.parseInt(Address, 2)];
            } else if ("10".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX2, 2) + Integer.parseInt(Address, 2)];
            } else if ("11".equals(IXNum)) {
                IARvalue = memory[Integer.parseInt(IX3, 2) + Integer.parseInt(Address, 2)];
            } else {
                jTextField1.setText("Wrong IX value");
            }
        }

        //get new Effective Address in IARvalue
        IAR.setText(IARvalue);
        //jTextField1.setText(IARvalue);
        /*for (int i = 0; i < 16; i++) {//go through cache
            if (cache[i][1].equals(IARvalue)) {
                jTextField1.setText("Cache hit: " + MBRvalue + " in cache at: index" + i);//hit    

                MBRvalue = cache[i][1];
                MBR.setText(MBRvalue);         //retrive from cache, store in MBR
                jTextField1.setText("Cache retrived: value " + MBRvalue + " from cache at: index" + i);//hit
                //set boxes
                //get value from memory,and do the subtraction and then put in GP-register determined by GRNum

                if ("00".equals(GRNum)) {
                    GPR0 -= Integer.parseInt(MBRvalue);
                    R0.setText(Integer.toBinaryString(GPR0));
                }
                if ("01".equals(GRNum)) {
                    GPR1 -= Integer.parseInt(MBRvalue);
                    R1.setText(Integer.toBinaryString(GPR1));
                }
                if ("10".equals(GRNum)) {
                    GPR2 -= Integer.parseInt(MBRvalue);
                    R2.setText(Integer.toBinaryString(GPR2));
                }
                if ("11".equals(GRNum)) {
                    GPR3 -= Integer.parseInt(MBRvalue);
                    R3.setText(Integer.toBinaryString(GPR3));
                }

                return;

            }

        }

        //else
        jTextField1.setText("Cache miss: " + MBRvalue + " in cache, " + "grabbing from Mem");//hit
         */
        //Modification end for cache
        //store IAR to MAR
        IAR.setText(IARvalue);
        //sleep

        MARaddress = IARvalue;
        MAR.setText(MARaddress);
        //and retrive it from memory, store in MBR

        MBRvalue = memory[Integer.parseInt(MARaddress, 2)];
        MBR.setText(MBRvalue);         //retrive, store in MBR
        //set boxes

        //get value from memory, put in cache first
        /*int cachefull = 1;
        for (int index = 0; index < 16; index++) {
            if (cache[index][2].equals("")) {//find a vacancy
                cachefull = 0;
                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                //put it in
                jTextField1.setText("Cache write successful.");
            }
        }

        if (cachefull == 1) {//cache full
            jTextField1.setText("Cache is full. Cleaning cache in FIFO way.");
            for (int index = 0; index < 16; index++) {
                if (!"".equals(cache[index][2])) {
                    cache[index][2] = "";
                }

                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                jTextField1.setText("Cache write successful.");
            }

        }*/
        //then do the subtraction and then put the result in GP-register determined by GRNum
        if ("00".equals(GRNum)) {
            GPR0 -= Integer.parseInt(MBRvalue, 2);
            R0.setText(Integer.toBinaryString(GPR0));
        }
        if ("01".equals(GRNum)) {
            GPR1 -= Integer.parseInt(MBRvalue, 2);
            R1.setText(Integer.toBinaryString(GPR1));
        }
        if ("10".equals(GRNum)) {
            GPR2 -= Integer.parseInt(MBRvalue, 2);
            R2.setText(Integer.toBinaryString(GPR2));
        }
        if ("11".equals(GRNum)) {
            GPR3 -= Integer.parseInt(MBRvalue, 2);
            R3.setText(Integer.toBinaryString(GPR3));
        }
        jTextField1.setText("Substraction done.");
        /*
        //get the next one, spatial locality
        String IARvaluenext = Integer.toBinaryString(Integer.parseInt(IARvalue, 2) + 1);
        IAR.setText(IARvaluenext);

        MARaddress = IARvaluenext;
        MAR.setText(MARaddress);
        //and retrive it from memory, store in MBR

        MBRvalue = memory[Integer.parseInt(MARaddress, 2)];
        MBR.setText(MBRvalue);         //retrive, store in MBR
        //set boxes

        //get value from memory, put in cache first
        cachefull = 1;
        for (int index = 0; index < 16; index++) {
            if (cache[index][2].equals("")) {//find a vacancy
                cachefull = 0;
                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                //put it in
                jTextField1.setText("Cache write successful.");
            }
        }

        if (cachefull == 1) {//cache full
            jTextField1.setText("Cache is full. Cleaning cache in FIFO way.");
            for (int index = 0; index < 16; index++) {
                if (!"".equals(cache[index][2])) {
                    cache[index][2] = "";
                }

                cache[index][1] = IARvalue;
                cache[index][2] = MBRvalue;
                jTextField1.setText("Cache write successful.");
            }

        }
         */
        return;
    }

    private void AIR() {
        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        IXNum = IRvalue.substring(8, 10);
        I = String.valueOf(IRvalue.charAt(10));
        Address = IRvalue.substring(11, 16);
        jTextField1.setText("Splitting instruction.");

        //if immed = 0, does nothing
        if (Integer.parseInt(Address) == 0) {
            return;
        }

        if ("00".equals(GRNum)) {
            GPR0 += Integer.parseInt(Address);
            R0.setText(Integer.toBinaryString(GPR0));
        }
        if ("01".equals(GRNum)) {
            GPR1 += Integer.parseInt(Address);
            R1.setText(Integer.toBinaryString(GPR1));
        }
        if ("10".equals(GRNum)) {
            GPR2 += Integer.parseInt(Address);
            R2.setText(Integer.toBinaryString(GPR2));
        }
        if ("11".equals(GRNum)) {
            GPR3 += Integer.parseInt(Address);
            R3.setText(Integer.toBinaryString(GPR3));
        }

    }

    private void SIR() {
        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        IXNum = IRvalue.substring(8, 10);
        I = String.valueOf(IRvalue.charAt(10));
        Address = IRvalue.substring(11, 16);
        jTextField1.setText("Splitting instruction.");

        //if immed = 0, does nothing
        if (Integer.parseInt(Address, 2) == 0) {
            return;
        }

        if ("00".equals(GRNum)) {
            GPR0 -= Integer.parseInt(Address, 2);
            R0.setText(Integer.toBinaryString(GPR0));
        }
        if ("01".equals(GRNum)) {
            GPR1 -= Integer.parseInt(Address, 2);
            R1.setText(Integer.toBinaryString(GPR1));
        }
        if ("10".equals(GRNum)) {
            GPR2 -= Integer.parseInt(Address, 2);
            R2.setText(Integer.toBinaryString(GPR2));
        }
        if ("11".equals(GRNum)) {
            GPR3 -= Integer.parseInt(Address, 2);
            R3.setText(Integer.toBinaryString(GPR3));
        }
    }

    private void MLT() {
        //splitting Rx Ry
        String GRx = IRvalue.substring(6, 8);
        String GRy = IRvalue.substring(8, 10);
        CCRvalue = CC.getText();
        if (("00".equals(GRx)) & ("10".equals(GRy))) {
            GPR0 = Integer.parseInt(R0.getText(), 2);
            GPR2 = Integer.parseInt(R2.getText(), 2);
            int Temp = GPR0 * GPR2;
            if (Temp > 65535) {
                CCRvalue = '1' + CCRvalue.substring(1);
                CC.setText(CCRvalue);  //OVERFLOW CC set
                R0.setText(Integer.toBinaryString(Temp).substring(0, 16));   //save higher order bits in R0
                R1.setText(Integer.toBinaryString(Temp).substring(16));     //save lower order bits in R1
                R2.setText("");         //clear R2
                jTextField1.setText("Multiply operation done.");
            } else {
                R1.setText(Integer.toBinaryString(Temp));
                R2.setText("");         //clear R2
                jTextField1.setText("Multiply operation done.");
            }
        } else if (("10".equals(GRx)) & ("00".equals(GRy))) {
            GPR0 = Integer.parseInt(R0.getText(), 2);
            GPR2 = Integer.parseInt(R2.getText(), 2);
            int Temp = GPR0 * GPR2;
            if (Temp > 65535) {
                CCRvalue = '1' + CCRvalue.substring(1);
                CC.setText(CCRvalue);  //OVERFLOW CC set
                R2.setText(Integer.toBinaryString(Temp).substring(0, 16));   //save higher order bits in R2
                R3.setText(Integer.toBinaryString(Temp).substring(16));     //save lower order bits in R3
                R0.setText("");         //clear R1
                jTextField1.setText("Multiply operation done.");
            } else {
                R3.setText(Integer.toBinaryString(Temp));
                R0.setText("");         //clear R2
                jTextField1.setText("Multiply operation done.");
            }
        } else {
            jTextField1.setText("Wrong GPR position. Must be R0 & R2.");
        }
    }

    private void DVD() {
        //splitting Rx Ry
        String GRx = IRvalue.substring(6, 8);
        String GRy = IRvalue.substring(8, 10);
        CCRvalue = CC.getText();
        if (("00".equals(GRx)) & ("10".equals(GRy))) {
            GPR0 = Integer.parseInt(R0.getText(), 2);
            GPR2 = Integer.parseInt(R2.getText(), 2);
            if (GPR2 == 0) {
                CCRvalue = CCRvalue.substring(0, 2) + '1' + CCRvalue.substring(3);
                CC.setText(CCRvalue);  //DIVZERO CC set
                jTextField1.setText("Illegal. Divisor is 0.");
            } else {
                int Quotient = GPR0 / GPR2;
                int Remainder = GPR0 % GPR2;
                R0.setText(Integer.toBinaryString(Quotient));   //save Quotient in R0
                R1.setText(Integer.toBinaryString(Remainder));     //save Remainder in R1
                jTextField1.setText("Divide operation done.");
            }
        } else if (("10".equals(GRx)) & ("00".equals(GRy))) {
            GPR0 = Integer.parseInt(R0.getText(), 2);
            GPR2 = Integer.parseInt(R2.getText(), 2);
            if (GPR0 == 0) {
                CCRvalue = CCRvalue.substring(0, 2) + '1' + CCRvalue.substring(3);
                CC.setText(CCRvalue);  //DIVZERO CC set
                jTextField1.setText("Illegal. Divisor is 0.");
            } else {
                int Quotient = GPR2 / GPR0;
                int Remainder = GPR2 % GPR0;
                R2.setText(Integer.toBinaryString(Quotient));   //save Quotient in R0
                R3.setText(Integer.toBinaryString(Remainder));     //save Remainder in R1
                jTextField1.setText("Divide operation done.");
            }
        } else {
            jTextField1.setText("Invalid Instruction. Wrong GPR position. Must be R0 & R2.");
        }
    }

    private void TRR() {
        //splitting Rx Ry
        int x = Integer.parseInt(IRvalue.substring(6, 8), 2);
        int y = Integer.parseInt(IRvalue.substring(8, 10), 2);
        CCRvalue = CC.getText();
        int[] GR = new int[4];
        //get value of GPR
        if (!"".equals(R0.getText())) {
            GR[0] = Integer.parseInt(R0.getText());
        }
        if (!"".equals(R1.getText())) {
            GR[1] = Integer.parseInt(R1.getText());
        }
        if (!"".equals(R2.getText())) {
            GR[2] = Integer.parseInt(R2.getText());
        }
        if (!"".equals(R3.getText())) {
            GR[3] = Integer.parseInt(R3.getText());
        }
        if (GR[x] == GR[y]) {
            CCRvalue = CCRvalue.substring(0, 3) + "1";
            CC.setText(CCRvalue);
        } else {
            CCRvalue = CCRvalue.substring(0, 3) + "0";
            CC.setText(CCRvalue);
        }
        jTextField1.setText("CC set.");
    }

    private void AND() {
        //splitting Rx Ry
        int x = Integer.parseInt(IRvalue.substring(6, 8), 2);
        int y = Integer.parseInt(IRvalue.substring(8, 10), 2);
        int[] GR = new int[4];
        //get value of GPR
        if (!"".equals(R0.getText())) {
            GR[0] = Integer.parseInt(R0.getText(), 2);
        }
        if (!"".equals(R1.getText())) {
            GR[1] = Integer.parseInt(R1.getText(), 2);
        }
        if (!"".equals(R2.getText())) {
            GR[2] = Integer.parseInt(R2.getText(), 2);
        }
        if (!"".equals(R3.getText())) {
            GR[3] = Integer.parseInt(R3.getText(), 2);
        }
        int Temp = GR[x] & GR[y];
        if (x == 0) {
            R0.setText(Integer.toBinaryString(Temp));
        }
        if (x == 1) {
            R1.setText(Integer.toBinaryString(Temp));
        }
        if (x == 2) {
            R2.setText(Integer.toBinaryString(Temp));
        }
        if (x == 3) {
            R3.setText(Integer.toBinaryString(Temp));
        }
        jTextField1.setText("AND operation done.");
    }

    private void ORR() {
        //splitting Rx Ry
        int x = Integer.parseInt(IRvalue.substring(6, 8), 2);
        int y = Integer.parseInt(IRvalue.substring(8, 10), 2);
        int[] GR = new int[4];
        //get value of GPR
        if (!"".equals(R0.getText())) {
            GR[0] = Integer.parseInt(R0.getText(), 2);
        }
        if (!"".equals(R1.getText())) {
            GR[1] = Integer.parseInt(R1.getText(), 2);
        }
        if (!"".equals(R2.getText())) {
            GR[2] = Integer.parseInt(R2.getText(), 2);
        }
        if (!"".equals(R3.getText())) {
            GR[3] = Integer.parseInt(R3.getText(), 2);
        }
        int Temp = GR[x] | GR[y];
        if (x == 0) {
            R0.setText(Integer.toBinaryString(Temp));
        }
        if (x == 1) {
            R1.setText(Integer.toBinaryString(Temp));
        }
        if (x == 2) {
            R2.setText(Integer.toBinaryString(Temp));
        }
        if (x == 3) {
            R3.setText(Integer.toBinaryString(Temp));
        }
        jTextField1.setText("OR operation done.");
    }

    private void NOT() {
        GRNum = IRvalue.substring(6, 8);
        if ("00".equals(GRNum)) {
            R0.setText(Integer.toBinaryString(~Integer.parseInt(R0.getText(), 2)));
        }
        if ("01".equals(GRNum)) {
            R1.setText(Integer.toBinaryString(~Integer.parseInt(R1.getText(), 2)));
        }
        if ("10".equals(GRNum)) {
            R2.setText(Integer.toBinaryString(~Integer.parseInt(R2.getText(), 2)));
        }
        if ("11".equals(GRNum)) {
            R3.setText(Integer.toBinaryString(~Integer.parseInt(R3.getText(), 2)));
        }
        jTextField1.setText("NOT operation done.");
    }

    private void SRC() {//ä¿®æ”¹ 3.31 6ï¼š43
        //Split the instruction up

        //add more variable
        GRNum = IRvalue.substring(6, 8);
        A_L = IRvalue.substring(8, 9);
        L_R = IRvalue.substring(9, 10);
        count = IRvalue.substring(12, 16);
        jTextField1.setText("Splitting instruction.");
        int intCount = Integer.parseInt(count); //for convenience

        //if count = 0, does nothing
        if (intCount == 0) {
            return;
        }

        if ("1".equals(A_L)) {
            //shift logically
            if ("1".equals(L_R)) {
                //left shift
                for (int i = 0; i < intCount; i++) {
                    if ("00".equals(GRNum)) {
                        String sGPR0 = Integer.toBinaryString(GPR0) + "0";
                        GPR0 = Integer.parseInt(((sGPR0).substring(1, sGPR0.length())), 2);
                        R0.setText(Integer.toBinaryString(GPR0));
                    }
                    if ("01".equals(GRNum)) {
                        String sGPR1 = Integer.toBinaryString(GPR1) + "0";
                        GPR1 = Integer.parseInt(((sGPR1).substring(1, sGPR1.length())), 2);
                        R1.setText(Integer.toBinaryString(GPR1));
                    }
                    if ("10".equals(GRNum)) {
                        String sGPR2 = Integer.toBinaryString(GPR2) + "0";
                        GPR1 = Integer.parseInt(((sGPR2).substring(1, sGPR2.length())), 2);
                        R2.setText(Integer.toBinaryString(GPR2));
                    }
                    if ("11".equals(GRNum)) {
                        String sGPR3 = Integer.toBinaryString(GPR3) + "0";
                        GPR1 = Integer.parseInt(((sGPR3).substring(1, sGPR3.length())), 2);
                        R3.setText(Integer.toBinaryString(GPR3));
                    }
                }
            } else if ("0".equals(L_R)) {
                //right shift
                for (int i = 0; i < intCount; i++) {
                    if ("00".equals(GRNum)) {
                        String sGPR0 = "0" + Integer.toBinaryString(GPR0);
                        GPR0 = Integer.parseInt(((sGPR0).substring(0, sGPR0.length() - 1)), 2);
                        R0.setText(Integer.toBinaryString(GPR0));
                    }
                    if ("01".equals(GRNum)) {
                        String sGPR1 = "0" + Integer.toBinaryString(GPR1);
                        GPR1 = Integer.parseInt(((sGPR1).substring(0, sGPR1.length() - 1)), 2);
                        R1.setText(Integer.toBinaryString(GPR1));
                    }
                    if ("10".equals(GRNum)) {
                        String sGPR2 = "0" + Integer.toBinaryString(GPR2);
                        GPR2 = Integer.parseInt(((sGPR2).substring(0, sGPR2.length() - 1)), 2);
                        R2.setText(Integer.toBinaryString(GPR2));
                    }
                    if ("11".equals(GRNum)) {
                        String sGPR3 = "0" + Integer.toBinaryString(GPR3);
                        GPR0 = Integer.parseInt(((sGPR3).substring(0, sGPR3.length() - 1)), 2);
                        R3.setText(Integer.toBinaryString(GPR3));
                    }
                }
            } else {
                System.out.println("Wrong L/R!");
            }
        } else if ("0".equals(A_L)) {
            //arithmetic shift
            if ("1".equals(L_R)) {
                //left shift
                for (int i = 0; i < intCount; i++) {
                    if ("00".equals(GRNum)) {
                        String sGPR0 = Integer.toBinaryString(GPR0) + "0";
                        GPR0 = Integer.parseInt(((sGPR0).substring(1, sGPR0.length())), 2);
                        R0.setText(Integer.toBinaryString(GPR0));
                    }
                    if ("01".equals(GRNum)) {
                        String sGPR1 = Integer.toBinaryString(GPR1) + "0";
                        GPR1 = Integer.parseInt(((sGPR1).substring(1, sGPR1.length())), 2);
                        R1.setText(Integer.toBinaryString(GPR1));
                    }
                    if ("10".equals(GRNum)) {
                        String sGPR2 = Integer.toBinaryString(GPR2) + "0";
                        GPR1 = Integer.parseInt(((sGPR2).substring(1, sGPR2.length())), 2);
                        R2.setText(Integer.toBinaryString(GPR2));
                    }
                    if ("11".equals(GRNum)) {
                        String sGPR3 = Integer.toBinaryString(GPR3) + "0";
                        GPR1 = Integer.parseInt(((sGPR3).substring(1, sGPR3.length())), 2);
                        R3.setText(Integer.toBinaryString(GPR3));
                    }
                }
            } else if ("0".equals(L_R)) {
                //right shift
                for (int i = 0; i < intCount; i++) {
                    if ("00".equals(GRNum)) {
                        String sGPR00 = Integer.toBinaryString(GPR0);
                        while (sGPR00.length() < 16) {
                            sGPR00 = "0" + sGPR00;
                        }
                        String sGPR0 = sGPR00.substring(15, 16) + sGPR00;
                        GPR0 = Integer.parseInt((sGPR0).substring(0, 16), 2);//å› ä¸ºæœ€å¼€å§‹è®¾è®¡äº†GPRæ˜¯intç±»åž‹æ‰€ä»¥å…¶å®žæˆªå�–å­—ç¬¦ä¸²æ˜¯ä¸�å‡†ç¡®çš„
                        R0.setText(Integer.toBinaryString(GPR0));
                    }
                    if ("01".equals(GRNum)) {
                        String sGPR11 = Integer.toBinaryString(GPR1);
                        while (sGPR11.length() < 16) {
                            sGPR11 = "0" + sGPR11;
                        }
                        String sGPR1 = sGPR11.substring(15, 16) + sGPR11;
                        GPR1 = Integer.parseInt((sGPR1).substring(0, 16), 2);
                        R1.setText(Integer.toBinaryString(GPR1));
                    }
                    if ("10".equals(GRNum)) {
                        String sGPR22 = Integer.toBinaryString(GPR2);
                        while (sGPR22.length() < 16) {
                            sGPR22 = "0" + sGPR22;
                        }
                        String sGPR2 = sGPR22.substring(15, 16) + sGPR22;
                        GPR2 = Integer.parseInt((sGPR2).substring(0, 16), 2);
                        R2.setText(Integer.toBinaryString(GPR2));
                    }
                    if ("11".equals(GRNum)) {
                        String sGPR33 = Integer.toBinaryString(GPR3);
                        while (sGPR33.length() < 16) {
                            sGPR33 = "0" + sGPR33;
                        }
                        String sGPR3 = sGPR33.substring(15, 16) + sGPR33;
                        GPR3 = Integer.parseInt((sGPR3).substring(0, 16), 2);
                        R3.setText(Integer.toBinaryString(GPR3));
                    }
                }
            } else {
                System.out.println("Wrong L_R!");
            }
        } else {
            System.out.println("Wrong A/L!");
        }
    }

    private void RRC() {//ä¿®æ”¹ 3.31 7:19
        //Split the instruction up
        GRNum = IRvalue.substring(6, 8);
        A_L = IRvalue.substring(8, 9);
        L_R = IRvalue.substring(9, 10);
        count = IRvalue.substring(12, 16);
        jTextField1.setText("Splitting instruction.");
        int intCount = Integer.parseInt(count); //for convenience

        //if count = 0, does nothing
        if (intCount == 0) {
            return;
        }

        if ("1".equals(L_R)) {
            //left rotate
            for (int i = 0; i < intCount; i++) {
                if ("00".equals(GRNum)) {
                    String sGPR00 = Integer.toBinaryString(GPR0);
                    while (sGPR00.length() < 16) {
                        sGPR00 = "0" + sGPR00;
                    }
                    String sGPR0 = sGPR00 + sGPR00.substring(0, 1);
                    //String sGPR0 = Integer.toBinaryString(GPR0) + Integer.toBinaryString(GPR0).substring(0, 1);
                    GPR0 = Integer.parseInt((sGPR0.substring(1, sGPR0.length())), 2);
                    R0.setText(Integer.toBinaryString(GPR0));
                }
                if ("01".equals(GRNum)) {
                    String sGPR11 = Integer.toBinaryString(GPR1);
                    while (sGPR11.length() < 16) {
                        sGPR11 = "0" + sGPR11;
                    }
                    String sGPR1 = sGPR11 + sGPR11.substring(0, 1);
                    //String sGPR1 = Integer.toBinaryString(GPR1) + Integer.toBinaryString(GPR1).substring(0, 1);
                    GPR1 = Integer.parseInt((sGPR1.substring(1, sGPR1.length())), 2);
                    R1.setText(Integer.toBinaryString(GPR1));
                }
                if ("10".equals(GRNum)) {
                    String sGPR22 = Integer.toBinaryString(GPR2);
                    while (sGPR22.length() < 16) {
                        sGPR22 = "0" + sGPR22;
                    }
                    String sGPR2 = sGPR22 + sGPR22.substring(0, 1);
                    //String sGPR2 = Integer.toBinaryString(GPR2) + Integer.toBinaryString(GPR2).substring(0, 1);
                    GPR2 = Integer.parseInt((sGPR2.substring(1, sGPR2.length())), 2);
                    R2.setText(Integer.toBinaryString(GPR2));
                }
                if ("11".equals(GRNum)) {
                    String sGPR33 = Integer.toBinaryString(GPR3);
                    while (sGPR33.length() < 16) {
                        sGPR33 = "0" + sGPR33;
                    }
                    String sGPR3 = sGPR33 + sGPR33.substring(0, 1);
                    //String sGPR3 = Integer.toBinaryString(GPR3) + Integer.toBinaryString(GPR3).substring(0, 1);
                    GPR3 = Integer.parseInt((sGPR3.substring(1, sGPR3.length())), 2);
                    R3.setText(Integer.toBinaryString(GPR3));
                }
            }
        } else if ("0".equals(L_R)) {
            //right rotate
            for (int i = 0; i < intCount; i++) {
                if ("00".equals(GRNum)) {
                    String sGPR00 = Integer.toBinaryString(GPR0);
                    while (sGPR00.length() < 16) {
                        sGPR00 = "0" + sGPR00;
                    }
                    String sGPR0 = sGPR00.substring(15, 16) + sGPR00;
                    GPR0 = Integer.parseInt((sGPR0).substring(0, 16), 2);//å› ä¸ºæœ€å¼€å§‹è®¾è®¡äº†GPRæ˜¯intç±»åž‹æ‰€ä»¥å…¶å®žæˆªå�–å­—ç¬¦ä¸²æ˜¯ä¸�å‡†ç¡®çš„
                    R0.setText(Integer.toBinaryString(GPR0));
                }
                if ("01".equals(GRNum)) {
                    String sGPR11 = Integer.toBinaryString(GPR1);
                    while (sGPR11.length() < 16) {
                        sGPR11 = "0" + sGPR11;
                    }
                    String sGPR1 = sGPR11.substring(15, 16) + sGPR11;
                    GPR1 = Integer.parseInt((sGPR1).substring(0, 16), 2);
                    R1.setText(Integer.toBinaryString(GPR1));
                }
                if ("10".equals(GRNum)) {
                    String sGPR22 = Integer.toBinaryString(GPR2);
                    while (sGPR22.length() < 16) {
                        sGPR22 = "0" + sGPR22;
                    }
                    String sGPR2 = sGPR22.substring(15, 16) + sGPR22;
                    GPR2 = Integer.parseInt((sGPR2).substring(0, 16), 2);
                    R2.setText(Integer.toBinaryString(GPR2));
                }
                if ("11".equals(GRNum)) {
                    String sGPR33 = Integer.toBinaryString(GPR3);
                    while (sGPR33.length() < 16) {
                        sGPR33 = "0" + sGPR33;
                    }
                    String sGPR3 = sGPR33.substring(15, 16) + sGPR33;
                    GPR3 = Integer.parseInt((sGPR3).substring(0, 16), 2);
                    R3.setText(Integer.toBinaryString(GPR3));
                }
            }
        } else {
            System.out.println("Wrong L_R!");
        }
    }

    private void IN() {
        // add variable string DevID
        GRNum = IRvalue.substring(6, 8);
        DevID = IRvalue.substring(11, 16);
        if (0 == Integer.parseInt(DevID)) {
            jTextField1.setText("Input next char from Console KeyBoard");
            IARvalue = Integer.toBinaryString(Integer.parseInt(KeyboardInput.getText()));
        } else if (2 == Integer.parseInt(DevID)) {
            jTextField1.setText("Input next char from Card Reader");
            return;
        } else if (Integer.parseInt(DevID) > 2 && Integer.parseInt(DevID) < 32) {
            jTextField1.setText("Input next char from Console registers or switches");
            return;
        } else {
            jTextField1.setText("Invalid Device ID");
            return;
        }
        if ("00".equals(GRNum)) {
            GPR0 = Integer.parseInt(IARvalue, 2);
            R0.setText(IARvalue);
            jTextField1.setText("R0 get input char from peripheral successful");
        }
        if ("01".equals(GRNum)) {
            GPR1 = Integer.parseInt(IARvalue);
            R1.setText(IARvalue);
            jTextField1.setText("R1 get input char from peripheral successful");
        }
        if ("10".equals(GRNum)) {
            GPR2 = Integer.parseInt(IARvalue);
            R2.setText(IARvalue);
            jTextField1.setText("R2 get input char from peripheral successful");
        }
        if ("11".equals(GRNum)) {
            GPR3 = Integer.parseInt(IARvalue);
            R3.setText(IARvalue);
            jTextField1.setText("R3 get input char from peripheral successful");
        }
    }

    private void OUT() {
        GRNum = IRvalue.substring(6, 8);
        DevID = IRvalue.substring(11, 16);
        if ("00".equals(GRNum)) {
            IARvalue = Integer.toBinaryString(GPR0);
        } else if ("01".equals(GRNum)) {
            IARvalue = Integer.toBinaryString(GPR1);
        } else if ("10".equals(GRNum)) {
            IARvalue = Integer.toBinaryString(GPR2);
        } else if ("11".equals(GRNum)) {
            IARvalue = Integer.toBinaryString(GPR3);
        }
        if (1 == Integer.parseInt(DevID)) {
            jTextField1.setText("Out put register " + Integer.parseInt(GRNum)
                    + " to Console printer");
            PrinterOutput.setText(IARvalue);
        } else if (2 < Integer.parseInt(DevID) && Integer.parseInt(DevID) < 32) {
            jTextField1.setText("Out put register " + Integer.parseInt(GRNum)
                    + "' char value" + (char) Integer.parseInt(IARvalue) + " to Console registers or switches");
        } else {
            jTextField1.setText("Invalid Device ID");
        }

    }

    private void CHK() {
        GRNum = IARvalue.substring(6, 8);
        DevID = IARvalue.substring(11, 16);
        if (0 == Integer.parseInt(DevID)) {
            jTextField1.setText("Console Keyboard' status transfer to Register" + Integer.parseInt(GRNum));
        } else if (1 == Integer.parseInt(DevID)) {
            jTextField1.setText("Console Printer' status transfer to Register" + Integer.parseInt(GRNum));
        } else if (2 == Integer.parseInt(DevID)) {
            jTextField1.setText("Card Reader' status transfer to Register" + Integer.parseInt(GRNum));
        } else if (2 < Integer.parseInt(DevID) && Integer.parseInt(DevID) > 32) {
            jTextField1.setText("Console registers' or switches' status transfer to Register" + Integer.parseInt(GRNum));
        } else {
            jTextField1.setText("Invalid Device ID");
        }
    }

    //do not achieve in this part
    private void FADD() {
        jTextField1.setText("This function do not achieve in this part");
    }

    //do not achieve in this part
    private void FSUB() {
        jTextField1.setText("This function do not achieve in this part");

    }

    //do not achieve in this part
    private void VADD() {
        jTextField1.setText("This function do not achieve in this part");

    }

    //do not achieve in this part
    private void VSUB() {
        jTextField1.setText("This function do not achieve in this part");

    }

    //do not achieve in this part
    private void CNVRT() {
        jTextField1.setText("This function do not achieve in this part");

    }

    //do not achieve in this part
    private void LDFR() {
        jTextField1.setText("This function do not achieve in this part");

    }

    //do not achieve in this part
    private void STFR() {
        jTextField1.setText("This function do not achieve in this part");

    }

    //sleep, to be completed
    //Forfeited method
    /*
    private void SingleStepSleep(){
        
        if(true==SingleStepFlag){
            while(Flag2){
                try {
                    sleep(1000);
                } catch (InterruptedException ex) {//auto generated try-catch
                    Logger.getLogger(GUI.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            
            Flag2 = true;
            
        }
        
    }
    
     */
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {

        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GUI().setVisible(true);
            }
        });

    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField CC;
    private javax.swing.JButton Directset;
    private javax.swing.JTextField IAR;
    private javax.swing.JTextField IR;
    private javax.swing.JButton Init;
    private javax.swing.JButton InitializedP2;
    private javax.swing.JTextField KeyboardInput;
    private javax.swing.JTextField MAR;
    private javax.swing.JTextField MBR;
    private javax.swing.JTextField MFR;
    private javax.swing.JTextField PC;
    private javax.swing.JTextField PrinterOutput;
    private javax.swing.JButton Program2;
    private javax.swing.JTextField R0;
    private javax.swing.JTextField R1;
    private javax.swing.JTextField R2;
    private javax.swing.JTextField R3;
    private javax.swing.JButton Run;
    private javax.swing.JButton SetMAR;
    private javax.swing.JButton SetMBR;
    private javax.swing.JButton SetPC;
    private javax.swing.JButton SetR0;
    private javax.swing.JButton SetR1;
    private javax.swing.JButton SetR2;
    private javax.swing.JButton SetR3;
    private javax.swing.JButton SetX1;
    private javax.swing.JButton SetX2;
    private javax.swing.JButton SetX3;
    private javax.swing.JButton SingleStep;
    private javax.swing.JTextField X1;
    private javax.swing.JTextField X2;
    private javax.swing.JTextField X3;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel19;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel20;
    private javax.swing.JLabel jLabel21;
    private javax.swing.JLabel jLabel22;
    private javax.swing.JLabel jLabel23;
    private javax.swing.JLabel jLabel24;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JTextField jTextField1;
    // End of variables declaration//GEN-END:variables
}
